# -*- mode: ruby -*-
# vi: set ft=ruby :
#
# This file is meant to contain vars that are most likely to be changed
# when configuring Rambo. Further logic is loaded with a Vagrantfile for a specific provider (e.g. ec2, lxc).

require "json"

# Change CWD for each VM, as set by Rambo, otherwise relative path resources break.
if ENV.has_key?("VAGRANT_CWD")
  Dir.chdir ENV["VAGRANT_CWD"]
end

require_relative "vagrant/modules.rb" # for random_tag

## Default Settings
SETTINGS = JSON.parse(File.read('settings.json'))
PROJECT_NAME = SETTINGS["PROJECT_NAME"]
RANDOMTAG = random_tag()
FORWARD_SSH = true
CUSTOM_PKG_SRC = true
if get_env_var_rb('vm_name')
  VM_NAME = get_env_var_rb('vm_name')
else
  VM_NAME = PROJECT_NAME + "-" + RANDOMTAG
end
unless get_env_var_rb('cwd')
  set_env_var_rb('cwd', Dir.pwd)
end

unless get_env_var_rb("ENV")
  puts "", "***CAUTION***",
       "Running Vagrant directly and without %s's official CLI." % PROJECT_NAME.capitalize,
       "This is not supported.",
       "***/CAUTION***", ""
end

Vagrant.require_version ">= 2.1.0"

orphan_links = `find . -xtype l`.split(/\n+/)
for link in orphan_links
  puts "Deleting broken symlink #{link}"
  File.delete(link)
end

#load the rest of the vagrant ruby code
provider = if get_env_var_rb("PROVIDER")
           get_env_var_rb("PROVIDER")
         elsif read_provider_file()
           read_provider_file()
         else
           'virtualbox'
         end

if (SETTINGS["PROVIDERS"].include? provider)
  write_provider_file(provider)
  load File.expand_path("vagrant/vagrantfiles/" + provider)
else # Bad arg - we don't have this provider.
  abort("ABORTED - Provider not in providers list. Did you have a typo?")
end

# Set defaults if values not set, otherwise
unless get_env_var_rb('GUEST_OS')
  set_env_var_rb('GUEST_OS', SETTINGS['GUEST_OSES_DEFAULT'])
end
unless get_env_var_rb('RAMSIZE')
  set_env_var_rb('RAMSIZE', SETTINGS['RAMSIZE_DEFAULT'])
end
unless get_env_var_rb('DRIVESIZE')
  set_env_var_rb('DRIVESIZE', SETTINGS['DRIVESIZE_DEFAULT'])
end



# Provisioning
Vagrant.configure("2") do |config|
  # Set hostname
  if get_env_var_rb('hostname')
    config.vm.hostname = get_env_var_rb('hostname')
  else
    config.vm.hostname = VM_NAME
  end

  # Syncing / Shared folders
  if get_env_var_rb('project_dir')
    sync_dir = get_env_var_rb('project_dir')
  else
    sync_dir = get_env_var_rb('cwd')
  end

  if get_env_var_rb('sync_type') != 'disabled'
    # Sync rambo project dir to /vagrant
    config.vm.synced_folder sync_dir, "/vagrant",
      type: get_env_var_rb('sync_type'),
      rsync__exclude: ['saltstack/'] # only provisioning code in project dir
    # Sync saltstack/{etc,srv}
    if Dir.exist?(File.join(sync_dir, "saltstack/etc"))
       config.vm.synced_folder File.join(sync_dir, "saltstack/etc"),
         "/etc/salt", type: get_env_var_rb('sync_type')
    end
    if Dir.exist?(File.join(sync_dir, "saltstack/srv"))
       config.vm.synced_folder File.join(sync_dir, "saltstack/srv"),
         "/srv", type: get_env_var_rb('sync_type')
    end

    # Sync all other code dirs
    custom_code_dirs = [
      'ansible',
      'chef',
      'puppet',
      'saltstack',
      'shell',
      'vagrant',
    ]
    for custom_code_dir in custom_code_dirs
      if Dir.exist?(File.join(sync_dir, custom_code_dir))
        config.vm.synced_folder File.join(sync_dir, custom_code_dir),
          File.join("/vagrant", custom_code_dir), type: get_env_var_rb('sync_type')
      end
    end

    # Sync custom dirs
    if get_env_var_rb('sync_dirs')
      sync_dirs = eval(get_env_var_rb('sync_dirs'))
      for sd in sync_dirs
        config.vm.synced_folder sd[0], sd[1], type: get_env_var_rb('sync_type')
      end
    end

  else # Disable all syncing. Breaks default method of provisioning.
    config.vm.synced_folder sync_dir, "/vagrant", disabled: true
  end

  if CUSTOM_PKG_SRC == true
    config.vm.provision "shell",
      inline: "if [ -f /etc/apt/sources.list ]; then wget -O /etc/apt/sources.list https://raw.githubusercontent.com/terminal-labs/package-sources/master/" + get_env_var_rb("GUEST_OS") + "/official/sources.list || true; fi",
      keep_color: true
  end

  # Provisioning
  if get_env_var_rb('provision_cmd')
    config.vm.provision "shell",
      inline: get_env_var_rb('provision_cmd'), keep_color: true
  end
  if get_env_var_rb('provision_script')
    config.vm.provision "shell",
      path: get_env_var_rb('provision_script'), keep_color: true
  end
  if get_env_var_rb('provision_with_salt') and Dir.exist?(File.join(sync_dir, 'saltstack'))
    config.vm.provision :salt do |salt|
      salt.bootstrap_options = get_env_var_rb('salt_bootstrap_args')
      salt.verbose = true
    end
    # Bash to set, prepare, and initiate Salt provisioning.
    $salt = <<-EOS
      # mv /etc/salt/minion{,-dist}
      # cp /vagrant/saltstack/minions/minion.#{provider}  /etc/salt/minion
      # cp /vagrant/saltstack/grains/grains /etc/salt/grains
      # mkdir -p /vagrant/saltstack/srv/salt/files/licenses
      # if [ -d "/vagrant/auth/licenses/" ]; then
      #     cp -a /vagrant/auth/licenses/. /vagrant/saltstack/srv/salt/files/licenses/
      # fi
      # if [ #{ENV["WEBSITE_BRANCH"]} ]; then
      #     sudo SSH_AUTH_SOCK=$SSH_AUTH_SOCK salt-call --local grains.setval WEBSITE_BRANCH #{ENV["WEBSITE_BRANCH"]}
      # fi
      # sudo SSH_AUTH_SOCK=$SSH_AUTH_SOCK salt-call --local grains.setval id #{get_env_var_rb('hostname')}
      # sudo SSH_AUTH_SOCK=$SSH_AUTH_SOCK salt-call --local grains.setval randomtag #{RANDOMTAG}
      sudo SSH_AUTH_SOCK=$SSH_AUTH_SOCK salt-call --local state.highstate
      EOS
    config.vm.provision "shell",
      inline: $salt, keep_color: true
  end
end

# clean up files on the host after the guest is destroyed
Vagrant.configure("2") do |config|
  config.trigger.after :up do |trigger|
    trigger.info = "Vagrant done with up."
  end
  config.trigger.after :destroy do |trigger|
    trigger.info = "Vagrant done with destroy."
  end
end
